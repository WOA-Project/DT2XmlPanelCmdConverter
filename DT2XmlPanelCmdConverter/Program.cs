// Buffer taken from the Device Tree of Surface Duo DV Left Panel directly.
byte[] buffer =
{
    0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x11, 0x00, //Sleep out command AND wait 120 ms
    0x0A, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80,
    0x11, 0x00, 0x00, 0x89, 0x30, 0x80, 0x07, 0x08,
    0x05, 0x46, 0x03, 0x84, 0x02, 0xA3, 0x02, 0xA3,
    0x02, 0x00, 0x02, 0x51, 0x00, 0x20, 0x5F, 0x4B,
    0x00, 0x09, 0x00, 0x0C, 0x00, 0x1C, 0x00, 0x18,
    0x18, 0x00, 0x10, 0xF0, 0x03, 0x0C, 0x20, 0x00,
    0x06, 0x0B, 0x0B, 0x33, 0x0E, 0x1C, 0x2A, 0x38,
    0x46, 0x54, 0x62, 0x69, 0x70, 0x77, 0x79, 0x7B,
    0x7D, 0x7E, 0x01, 0x02, 0x01, 0x00, 0x09, 0x40,
    0x09, 0xBE, 0x19, 0xFC, 0x19, 0xFA, 0x19, 0xF8,
    0x1A, 0x38, 0x1A, 0x78, 0x1A, 0xB6, 0x2A, 0xF6,
    0x2B, 0x34, 0x2B, 0x74, 0x3B, 0x74, 0x6B, 0xF4,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x15, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0xB0, 0xAC, //Unlock MCS
    0x39, 0x01, 0x00, 0x00, 0x00, 0x00, 0x05, 0x2A, 0x00, 0x00, 0x05, 0x45, //Window Size
    0x39, 0x01, 0x00, 0x00, 0x00, 0x00, 0x05, 0x2B, 0x00, 0x00, 0x07, 0x07, //Window Size
    0x15, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x26, 0x02, //Gama set
    0x39, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x44, 0x03, 0x84, //Scan line 1700
    0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x35, //TE ON
    0x39, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x51, 0x01, 0x47, //Write Brightness Value
    0x39, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x53, 0x0C, 0x30, //Write Control Display 1
    0x39, 0x01, 0x00, 0x00, 0x00, 0x00, 0x07, 0x55, 0x04, 0x70, 0xDB, 0x00, 0x78, 0xDB, //Write Control Display 2
    0x15, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0xEE, 0x24, //Pixel Reg Enable
    0x15, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0xFB, 0xAC, //OTP WP
    0x15, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0xB0, 0xCA, //lock MCS
    0x05, 0x01, 0x00, 0x00, 0x5A, 0x00, 0x01, 0x11, //Sleep out command AND wait 130 ms
    0x05, 0x01, 0x00, 0x00, 0x32, 0x00, 0x01, 0x29, //Display ON
    0x15, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0xB0, 0xAC, //Unlock MCS
    0x39, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0C, 0xE9, 0x32, 0x32, 0x55, 0x06, 0x00, 0x1C, 0x00, 0x00, 0x55, 0x50, 0x4B, //AGPC config
    0x39, 0x01, 0x00, 0x00, 0x00, 0x00, 0x16, 0xD0, 0x80, 0x10, 0x81, 0x02, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0C, 0x00, 0xD4, 0x0B, 0x00, 0x11, 0x00, 0x1C, //Gamma brightness for AGPC
    0x15, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0xB0, 0xCA, //lock MCS
    0x39, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x53, 0x0D, 0x30
};

/* - qcom,mdss-dsi-on-command:
 * A byte stream formed by multiple dcs packets base on
					qcom dsi controller protocol.
					byte 0: dcs data type
					byte 1: set to indicate this is an individual packet
						 (no chain)
					byte 2: virtual channel number
					byte 3: expect ack from client (dcs read command)
					byte 4: wait number of specified ms after dcs command
						 transmitted
					byte 5, 6: 16 bits length in network byte order
					byte 7 and beyond: number byte of payload*/

using var br = new BinaryReader(new MemoryStream(buffer));

br.BaseStream.Seek(0, SeekOrigin.Begin);

while (br.BaseStream.Position != buffer.Length)
{
    byte[] cmddets = br.ReadBytes(7);

    byte cmdtype = cmddets[0];
    byte delay = cmddets[4];
    int datalength = (cmddets[5] << 8) | cmddets[6];

    byte[] data = br.ReadBytes(datalength);

    Console.WriteLine($"{cmdtype:X2} {BitConverter.ToString(data).Replace("-", " ")}");
    if (delay != 0)
    {
        Console.WriteLine($"FF {delay:X2}"); // Delay Command
    }
}